const knex = require('../../db/knex');
const { calcLimitOffset } = require('../../helpers/calcLimitOffset');
const { transformFdaStatus } = require('../../helpers/dataHelpers');
const { retrieveFields } = require('../../helpers/queryHelpers');

/**
 * @param {Array} data
 * @returns {Array} - Returns a transformed array of objects.
 */
const transformGeneDrugs = data => {
    return data.map(gene_drug => {
        const {
            id,
            drug_id,
            estimate,
            se,
            n,
            tstat,
            fstat,
            pvalue,
            df,
            fdr,
            FWER_genes,
            FWER_drugs,
            FWER_all,
            BF_p_all,
            mDataType,
            level,
            drug_like_molecule,
            in_clinical_trials,
            dataset_id,
            dataset_name,
            drug_name,
            smiles,
            inchikey,
            pubchem,
            fda_status,
            tissue_id,
            tissue_name,
            gene_id,
            gene_name,
            ensg,
            gene_seq_start,
            gene_seq_end
        } = gene_drug;
        return {
            id,
            estimate,
            se,
            n,
            tstat,
            fstat,
            pvalue,
            df,
            fdr,
            FWER_genes,
            FWER_drugs,
            FWER_all,
            BF_p_all,
            mDataType,
            level,
            drug_like_molecule,
            in_clinical_trials,
            gene: {
                id: gene_id,
                name: gene_name,
                annotation: {
                    gene_id,
                    ensg,
                    gene_seq_start,
                    gene_seq_end
                }
            },
            dataset: {
                id: dataset_id,
                name: dataset_name
            },
            compound: {
                id: drug_id,
                name: drug_name,
                annotation: {
                    smiles,
                    inchikey,
                    pubchem,
                    fda_status: transformFdaStatus(fda_status)
                }
            },
            tissue: {
                id: tissue_id,
                name: tissue_name
            },
        };
    });
};

/**
 * Returns the transformed data for all the compounds in the database.
 * @param {Object} args - args object generated by GraphQL client (not used in the function).
 * @param {Object} context - parent object generated by GraphQL client (not used in the function).
 * @param {Object} info - info object generated by GraphQL client, contains data about requested fields.
 * @param {number} [args.geneId = 1] - GeneId for the query.
 * @param {number} [args.compoundId = 1] - CompoundId for the query.
 * @param {number} [args.page = 1] - Current page number.
 * @param {number} [args.per_page = 20] - Total values per page.
 * @param {boolean} [args.all = false] - Boolean value whether to show all the data or not.
 */
const gene_drugs = async (args, context, info) => {
    const { geneId, compoundId, page = 1, per_page = 20, all = false } = args;
    if (!geneId && !compoundId) throw new Error('Ivalid input! Query must include geneId or compoundId'); 
    try {
        const { limit, offset } = calcLimitOffset(page, per_page);
        const listOfFields = retrieveFields(info);
        // creates list of columns and list of subtypes for the knex query builder based on the fields requested by graphQL client
        const columns = [];
        const subtypes = [];
        listOfFields.forEach(el => {
            switch (el.name) {
            case 'dataset':
                columns.push(...['datasets.dataset_id as dataset_id', 'dataset_name']);
                subtypes.push(el.name);
                break;
            case 'gene':
                columns.push(...['genes.gene_id as gene_id', 'gene_name', 'ensg', 'gene_seq_start',
                    'gene_seq_end']);
                subtypes.push(el.name);
                break;
            case 'compound':
                columns.push(...['drugs.drug_id as drug_id', 'drug_name', 'smiles', 'inchikey', 'pubchem', 'fda_status']);
                subtypes.push(el.name);
                break;
            case 'tissue':
                columns.push(...['tissues.tissue_id as tissue_id', 'tissue_name']);
                subtypes.push(el.name);
                break;
            default:
                columns.push(el.name);
                break;
            }
        });
        let query = knex.select(columns);
        // chooses table to select from
        query = geneId ? query.from('gene_drugs as GD') : query.from('drug_genes as GD');
        if (geneId) query = query.where({ 'GD.gene_id': geneId });
        if (compoundId) query = geneId
            ? query.andWhere({ 'GD.drug_id': compoundId })
            : query.where({ 'GD.drug_id': compoundId });
        if (!all) query = query.limit(limit).offset(offset);
        // updates query to contain joins based on requested fields
        subtypes.forEach(subtype => {
            switch (subtype) {
            case 'dataset':
                query = query.join('datasets', 'datasets.dataset_id', 'GD.dataset_id');
                break;
            case 'gene':
                query = query.join('genes', 'genes.gene_id', 'GD.gene_id');
                break;
            case 'compound':
                query = query.join('drugs', 'drugs.drug_id', 'GD.drug_id')
                    .join('drug_annots', 'drug_annots.drug_id', 'GD.drug_id');
                break;
            case 'tissue':
                query = query.join('tissues', 'tissues.tissue_id', 'GD.tissue_id');
                break;
            }
        });
        const geneDrugResults = await query;
        return transformGeneDrugs(geneDrugResults);
    } catch (err) {
        console.log(err);
        throw err;
    }
};

module.exports = {
    gene_drugs
};